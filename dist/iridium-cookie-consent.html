<script>
// Iridium Webflow script `iridium-cookie-consent`

"use strict";

// src/iridium-cookie-consent/logger.ts
var logErr = (...args) => {
  console.error(
    "iridium-cc cookie consent:",
    ...args
  );
  const message = args.length === 1 ? `iridium-cc:${args[0]}` : `iridium-cc:${args}`;
  return new Error(message);
};
var logInfo = (...args) => {
  console.log("iridium-cc", ...args);
};

// src/iridium-cookie-consent/webflow.ts
var trackingChoicePrefix = "intellimize_user_tracking_choice_";

// src/iridium-cookie-consent/state.ts
var lsPrefixed = (which) => {
  return `iridium-cc:${which}`;
};
var readConsent = (which) => {
  const val = localStorage.getItem(lsPrefixed(which));
  if (val === null) {
    return null;
  }
  switch (val) {
    case "allow" /* ALLOW */:
    case "deny" /* DENY */:
      return val;
    default:
      return null;
  }
};
var setIntellimizeTrackingChoice = (consentChoice) => {
  logInfo("setting tracking choice to", consentChoice);
  const amountItems = localStorage.length;
  for (let i = 0; i < amountItems; i++) {
    const key = localStorage.key(i);
    if (key === null) {
      continue;
    }
    if (!key.startsWith(trackingChoicePrefix)) {
      continue;
    }
    logInfo("found correct localstorage item");
    localStorage.setItem(key, consentChoice);
    return;
  }
};
var purgeIntellimize = () => {
  const amountItems = localStorage.length;
  for (let i = 0; i < amountItems; i++) {
    const key = localStorage.key(i);
    if (key === null) {
      continue;
    }
    if (!key.startsWith("intellimize")) {
      continue;
    }
    logInfo("purging intellimize localstorage item", key);
    localStorage.removeItem(key);
  }
};
var initialState = () => {
  const component_b = readConsent("component_b");
  const component_c = readConsent("component_c");
  const component_a = readConsent("component_a");
  let checked = true;
  if (component_b === null) {
    checked = false;
  } else if (component_c === null) {
    checked = false;
  } else if (component_a === null) {
    checked = false;
  }
  const s = {
    checked,
    component_a: component_a === "allow" /* ALLOW */,
    component_b: component_b === "allow" /* ALLOW */,
    component_c: component_c === "allow" /* ALLOW */
  };
  return s;
};
var state = initialState();
var persist = () => {
  const keys = ["component_a", "component_b", "component_c"];
  for (const key of keys) {
    const lsKey = lsPrefixed(key);
    const value = state[key] ? "allow" /* ALLOW */ : "deny" /* DENY */;
    localStorage.setItem(lsKey, value);
  }
  if (state.component_a) {
    if (typeof wf !== "undefined") {
      wf.allowUserTracking({ activate: true });
    }
    setIntellimizeTrackingChoice("allow" /* ALLOW */);
  } else {
    if (typeof wf !== "undefined") {
      wf.denyUserTracking();
    }
    purgeIntellimize();
  }
};

// src/iridium-cookie-consent/api.ts
var allowAll = () => {
  state.checked = true;
  state.component_a = true;
  state.component_b = true;
  state.component_c = true;
  persist();
};
var denyAll = () => {
  state.checked = true;
  state.component_a = false;
  state.component_b = false;
  state.component_c = false;
  persist();
};
var toggleCheckbox = (which) => {
  const newVal = !state[which];
  state[which] = newVal;
  persist();
  logInfo("toggled checkbox", which, newVal);
  return newVal;
};

// src/iridium-cookie-consent/ui.ts
var ASK_BANNER = ".ir-notice";
var ASK_BANNER_DECLINE_BUTTON = "a.ir-notice-decline";
var ASK_BANNER_ACCEPT_BUTTON = '.ir-notice-accept[ir-action="allow"]';
var OPENER = ".ir-manager";
var DETAILS = ".ir-settings";
var CLOSE = ".ir-settings-close";
var OPTION_FIELD = ".ir-option";
var OPTION_CHECKBOX_VISUAL = ".switch-wrap";
var OPTION_TOGGLE_KNUB = ".circle";
var OPTION_CHECKBOX_INPUT = (which) => `[ir-toggle="${which}"]`;
var DISABLE_ALL_BUTTON = 'a.ir-settings-button[ir-action="deny"]';
var ALLOW_ALL_BUTTON = 'a.ir-settings-button[ir-action="allow"]';
var SAVE_SETTINGS_BUTTON = 'a.ir-settings-submit.w-button[ir-action="submit"]';
var initUi = (disableAll, allowAll2, onToggle, initialState2) => {
  const state2 = {
    askBanner: document.querySelector(ASK_BANNER),
    askBannerDeclineButton: document.querySelector(ASK_BANNER_DECLINE_BUTTON),
    askBannerAcceptButton: document.querySelector(ASK_BANNER_ACCEPT_BUTTON),
    opener: document.querySelector(OPENER),
    details: document.querySelector(DETAILS),
    close: document.querySelector(CLOSE),
    optionField: (which) => {
      const all = document.querySelectorAll(OPTION_FIELD);
      const selector = OPTION_CHECKBOX_INPUT(which);
      for (const candidate of all) {
        const correctCheckbox = candidate.querySelector(selector);
        if (correctCheckbox === null) {
          continue;
        }
        return candidate;
      }
      throw logErr("no candidate matches", which);
    },
    optionToggleVisual: (which) => {
      const all = document.querySelectorAll(OPTION_CHECKBOX_VISUAL);
      const selector = OPTION_CHECKBOX_INPUT(which);
      for (const candidate of all) {
        const root = candidate.parentElement;
        const correctCheckbox = root.querySelector(selector);
        if (correctCheckbox === null) {
          continue;
        }
        return candidate;
      }
      throw logErr("no candidate matches", which);
    },
    optionToggleKnub: (which) => {
      const all = document.querySelectorAll(OPTION_CHECKBOX_VISUAL);
      const selector = OPTION_CHECKBOX_INPUT(which);
      for (const candidate of all) {
        const root = candidate.parentElement;
        const correctCheckbox = root.querySelector(selector);
        if (correctCheckbox === null) {
          continue;
        }
        return candidate.querySelector(OPTION_TOGGLE_KNUB);
      }
      throw logErr("no candidate matches (knub)", which);
    },
    optionCheckboxInput: (which) => {
      return document.querySelector(OPTION_CHECKBOX_INPUT(which));
    },
    disableAllButton: document.querySelector(DISABLE_ALL_BUTTON),
    allowAllButton: document.querySelector(ALLOW_ALL_BUTTON),
    saveSettingsButton: document.querySelector(SAVE_SETTINGS_BUTTON)
  };
  for (const [key, val] of Object.entries(state2)) {
    switch (key) {
      case "optionField":
      case "optionCheckboxVisual":
      case "optionCheckboxInput":
        continue;
      default:
        if (val === null) {
          throw logErr("not found during ui setup", key);
        }
    }
  }
  const askBanner = {
    show: () => {
      logInfo("show ask banner");
      state2.askBanner.style.display = "flex";
      state2.opener.style.display = "none";
    },
    hide: () => {
      logInfo("hide ask banner");
      state2.askBanner.style.display = "none";
      state2.opener.style.display = "flex";
    }
  };
  const details = {
    show: () => {
      logInfo("show details banner");
      state2.opener.style.display = "none";
      state2.details.style.display = "flex";
    },
    hide: () => {
      logInfo("hide details banner");
      state2.details.style.display = "none";
      state2.opener.style.display = "flex";
    }
  };
  const check = (which) => {
    logInfo("ui check", which);
    const input = state2.optionCheckboxInput(which);
    const visual = state2.optionToggleVisual(which);
    const knub = state2.optionToggleKnub(which);
    input.checked = true;
    visual.classList.add("switch-checked");
    knub.classList.add("circle-checked");
    setTimeout(() => {
      input.checked = true;
      visual.classList.add("switch-checked");
      knub.classList.add("circle-checked");
    }, 0);
    logInfo(visual.classList);
  };
  const unCheck = (which) => {
    logInfo("ui uncheck", which);
    const input = state2.optionCheckboxInput(which);
    const visual = state2.optionToggleVisual(which);
    const knub = state2.optionToggleKnub(which);
    input.checked = false;
    visual.classList.remove("switch-checked");
    knub.classList.remove("circle-checked");
    setTimeout(() => {
      input.checked = false;
      visual.classList.remove("switch-checked");
      knub.classList.remove("circle-checked");
    }, 0);
    logInfo(visual.classList);
  };
  logInfo("setting up click listeners");
  for (const decliner of [state2.askBannerDeclineButton, state2.disableAllButton]) {
    decliner.addEventListener("click", () => {
      logInfo("clicked decliner", decliner);
      disableAll();
      unCheck("component_a");
      unCheck("component_b");
      unCheck("component_c");
      askBanner.hide();
      details.hide();
    });
  }
  state2.opener.addEventListener("click", details.show);
  state2.close.addEventListener("click", details.hide);
  state2.saveSettingsButton.addEventListener("click", details.hide);
  for (const accepter of [state2.askBannerAcceptButton, state2.allowAllButton]) {
    accepter.addEventListener("click", () => {
      logInfo("clicked accepter", accepter);
      allowAll2();
      check("component_a");
      check("component_b");
      check("component_c");
      askBanner.hide();
      details.hide();
    });
  }
  for (const category of ["component_a", "component_b", "component_c"]) {
    let debounce = false;
    state2.optionCheckboxInput(category).addEventListener("click", () => {
      console.log(JSON.stringify(initialState2));
      if (debounce) return;
      debounce = true;
      logInfo("clicked option of", category);
      const newVal = onToggle(category);
      if (newVal) {
        check(category);
      } else {
        unCheck(category);
      }
      setTimeout(() => {
        debounce = false;
      }, 50);
    });
  }
  logInfo("listeners fully wired up");
  logInfo("applying initial state to ui");
  if (initialState2.checked) {
    state2.opener.style.display = "flex";
    for (const category of ["component_a", "component_b", "component_c"]) {
      const checked = initialState2[category];
      if (checked) {
        check(category);
      } else {
        unCheck(category);
      }
    }
  } else {
    state2.askBanner.style.display = "flex";
  }
  console.log(state2);
  logInfo("setup routine done");
};

// src/iridium-cookie-consent/sleep.ts
var sleep = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

// src/iridium-cookie-consent/index.ts
var init = async (withWf) => {
  if (withWf) {
    logInfo("Beginning setup with `wf`");
  } else {
    logInfo("Beginning setup without `wf`");
  }
  logInfo("encountered initial state", JSON.stringify(state));
  let failed = true;
  let backoff = 5;
  const delay = () => {
    backoff = Math.ceil(backoff * 1.2);
  };
  while (failed) {
    logInfo("another trial for setup");
    try {
      initUi(
        denyAll,
        allowAll,
        toggleCheckbox,
        state
      );
      failed = false;
    } catch (e) {
      delay();
      await sleep(backoff);
      logErr("ran into problem during setup, trying again in", backoff);
      failed = true;
    }
  }
  logInfo("setup loop over");
};
if (typeof wf === "undefined") {
  init(false);
} else {
  wf.ready(() => {
    init(true);
  });
}

</script>
